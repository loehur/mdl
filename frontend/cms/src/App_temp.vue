<script setup>import { ref, computed, onMounted, nextTick, watch, onUnmounted } from 'vue';import { App } from '@capacitor/app';// Window resize listener helperconst windowWidth = ref(window.innerWidth);const updateWidth = () => windowWidth.value = window.innerWidth;window.addEventListener('resize', updateWidth);// --- State ---// --- State ---const conversations = ref([]);const activeChatId = ref(null);const messageInput = ref('');const chatContainer = ref(null);const socket = ref(null);const isConnected = ref(false);const showMobileChat = ref(false);const authId = ref('');const authPassword = ref(''); // Addedconst isConnecting = ref(false);const connectionError = ref('');const showExitToast = ref(false);let lastBackPress = 0;// Swipe Gesture Stateconst touchStartX = ref(0);const touchStartY = ref(0);const touchOffset = ref(0); // Current drag distanceconst isDragging = ref(false);const minSwipeDistance = 75; // px// Login Delay Stateconst showLoginPrompt = ref(false);const fetchConversations = async () => {    try {        const userIdParam = authId.value ? `?user_id=${authId.value}` : '';        const response = await fetch(`https://api.nalju.com/CMS/Chat/getConversations${userIdParam}`);                 if (!response.ok) {            const text = await response.text();            console.error("API Error Response:", text); // Use console so user can copy            return;        }        const result = await response.json();                // Backend returns "status": true, not "success"        if (result.status && Array.isArray(result.data)) {            // Check if filtering was expected            if (result.data.length === 0) {                 console.log("API returned 0 conversations.");            }            conversations.value = result.data.map(c => ({                id: c.id,                name: c.contact_name || c.wa_number,                kode_cabang: c.kode_cabang, // Add kode_cabang                avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${c.id}`,                status: c.status,                  lastMessage: c.last_message_text || 'No messages yet',                lastTime: c.last_message_time ? new Date(c.last_message_time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '',                unread: parseInt(c.unread_count) || 0,                messages: []             }));        } else {            console.error("API format error:", result);        }    } catch (e) {        console.error("Error fetching conversations:", e);    }};const connect = () => {    if(!authId.value) return;    isConnecting.value = true;    connectionError.value = '';    connectWebSocket();    fetchConversations();}// --- Computed ---const activeConversation = computed(() =>   conversations.value.find(c => c.id === activeChatId.value));// --- Methods ---// --- Methods ---const fetchMessages = async (conversationId) => {    try {        const response = await fetch(`https://api.nalju.com/CMS/Chat/getMessages?id=${conversationId}`);        const result = await response.json();                if (result.status && Array.isArray(result.data)) {            return result.data.map(m => ({                id: m.id,                text: m.text,                sender: m.sender, // 'me' or 'customer'                time: m.time ? new Date(m.time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '',                status: m.status            }));        }    } catch (e) {        console.error("Error loading messages:", e);    }    return [];};const markMessagesRead = async (conversationId) => {    try {        await fetch('https://api.nalju.com/CMS/Chat/markRead', {            method: 'POST',            headers: {'Content-Type': 'application/json'},            body: JSON.stringify({ conversation_id: conversationId })        });    } catch (e) { console.error(e); }};const scrollToBottom = () => {  nextTick(() => {    if (chatContainer.value) {      // Instant scroll without animation      chatContainer.value.scrollTop = chatContainer.value.scrollHeight;    }  });};const selectChat = async (id) => {  activeChatId.value = id;  showMobileChat.value = true;    const chat = conversations.value.find(c => c.id === id);  if (chat) {      // Optimistic read status      chat.unread = 0;            // Load messages      chat.messages = await fetchMessages(id);            // Mark read in DB      markMessagesRead(id);  }    scrollToBottom();};const backToMenu = () => {    touchOffset.value = 0; // Reset    showMobileChat.value = false;    activeChatId.value = null; // Deselect chat so unread counts increment};const sendMessage = async () => {  const text = messageInput.value.trim();  if (!text) return;    if (activeConversation.value) {    const tempId = Date.now();    const newMsg = {      id: tempId,      text: text,      sender: 'me',      time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),      status: 'pending'    };        // Optimistic UI    activeConversation.value.messages.push(newMsg);    activeConversation.value.lastMessage = "You: " + text;    activeConversation.value.lastTime = newMsg.time;        messageInput.value = '';    scrollToBottom();        // API Call    try {        const response = await fetch('https://api.nalju.com/CMS/Chat/reply', {            method: 'POST',            headers: {'Content-Type': 'application/json'},            body: JSON.stringify({                conversation_id: activeConversation.value.id,                message: text            })        });        const res = await response.json();                if (res.status) {            // Update status (not strictly needed if we reload, but good for UI)            const sentMsg = activeConversation.value.messages.find(m => m.id === tempId);            if(sentMsg) {                sentMsg.status = 'sent';                if (res.data && res.data.local_id) {                    sentMsg.id = res.data.local_id; // Swap temp ID with real DB ID                }            }        } else {             // Error state            const sentMsg = activeConversation.value.messages.find(m => m.id === tempId);            if(sentMsg) sentMsg.status = 'failed';            alert("Failed to send: " + (res.message || 'Unknown error'));        }    } catch (e) {        console.error("Reply error:", e);        const sentMsg = activeConversation.value.messages.find(m => m.id === tempId);        if(sentMsg) sentMsg.status = 'error';    }  }};const handleIncomingMessage = (payload) => {  // Check if this is a status update  if (payload.type === 'status_update') {      const { conversation_id, message } = payload;      const conversation = conversations.value.find(c => c.id === conversation_id);      if (conversation) {          // Find message by ID (preferred) or WAMID          const msgToUpdate = conversation.messages.find(m => m.id == message.id || m.wamid == message.wamid);          if (msgToUpdate) {              msgToUpdate.status = message.status;          }      }      return;  }  // Normal Message Handling  // Payload structure from webhook:  // { conversation_id, customer_id, phone, contact_name, message: { id, text, type, time }, target_id }    // Or fallback if direct  const conversationId = payload.conversation_id || payload.conversationId;  const messageData = payload.message || payload; // if message is nested or flat    const text = messageData.text;  const sender = messageData.sender || 'customer';  const name = payload.contact_name || payload.name;    // Find or create conversation  let conversation = conversations.value.find(c => c.id === conversationId);    if (!conversation) {    // New conversation    conversation = {      id: conversationId,      name: name || payload.phone || 'Unknown User',      avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${conversationId}`,      status: 'online', // Assume online on new msg      messages: [],      unread: 0    };    conversations.value.unshift(conversation);  }    const newMsg = {    id: messageData.id || Date.now(),    text: text,    sender: sender,    time: messageData.time ? new Date(messageData.time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })  };    // Avoid duplicate messages if already present  if (!conversation.messages.find(m => m.id === newMsg.id)) {      conversation.messages.push(newMsg);      conversation.lastMessage = newMsg.text;      conversation.lastTime = newMsg.time;        // Check visibility: Active ID matches AND (Desktop OR Mobile Chat View Open)  const isChatVisible = activeChatId.value == conversationId && (windowWidth.value >= 768 || showMobileChat.value);  if (!isChatVisible) {    conversation.unread++;  } else {    scrollToBottom();  }            // Move conversation to top      const idx = conversations.value.findIndex(c => c.id === conversation.id);      if (idx > 0) {        conversations.value.splice(idx, 1);        conversations.value.unshift(conversation);      }  }};const connectWebSocket = () => {  if (!authId.value) return;  console.log("Connecting to WebSocket with ID:", authId.value);    try {     const wsUrl = `wss://waserver.nalju.com?id=${authId.value.trim()}&password=${authPassword.value.trim()}`;     const ws = new WebSocket(wsUrl);      socket.value = ws;          ws.onopen = () => {       console.log('WebSocket connected');       isConnected.value = true;       isConnecting.value = false;       connectionError.value = '';              // Save session (3 days)       const expiry = new Date().getTime() + (3 * 24 * 60 * 60 * 1000);       localStorage.setItem('chat_connection_id', authId.value);       localStorage.setItem('chat_connection_expiry', expiry);     };          ws.onmessage = (event) => {       try {         const payload = JSON.parse(event.data);                  // Handle different message types         if (payload.type === 'connection' || payload.type === 'pong') {             // System messages, ignore for chat ui             console.log('WS System:', payload);             return;         }                  if (payload.type === 'wa_masuk') {             // Real incoming WA message             handleIncomingMessage(payload.data);         } else if (payload.conversationId) {             // Fallback for direct legacy format (if any)             handleIncomingMessage(payload);         }       } catch (e) {         console.error('Error parsing WS message', e);       }     };          ws.onclose = (event) => {       if (isConnected.value) {            console.log('WebSocket disconnected');            isConnected.value = false;       } else {           // Connection failed during attempt           isConnecting.value = false;           // Clear invalid session if we failed to connect (e.g. ID revoked)           // But be careful not to clear on transient network errors?            // Probably safe to let user try again or re-enter.           // For now, let's not clear automatically unless it's strictly Auth error (1008)                      let msg = 'Connection failed.';            if (event.code === 1008) {                msg = 'Access Denied: Invalid ID.';                localStorage.removeItem('chat_connection_id'); // Clear invalid ID                localStorage.removeItem('chat_connection_expiry');                showLoginPrompt.value = true; // Show login immediately on auth error            } else if (event.code === 1006) {                msg = 'Connection terminated abnormally.';                // If pure network error, maybe wait or show modal?                 // Let's show modal if we are truly disconnected for clarity                showLoginPrompt.value = true;            } else if (event.reason) {                msg = `Error: ${event.reason}`;                 showLoginPrompt.value = true;            }            connectionError.value = msg;        }     };          ws.onerror = (err) => {        // console.error('WS Error', err);     };  } catch (e) {    console.error(e);  }};const handleTouchStart = (e) => {  touchStartX.value = e.touches[0].screenX;  touchStartY.value = e.touches[0].screenY;  isDragging.value = false;};const handleTouchMove = (e) => {  if (!showMobileChat.value) return;    const currentX = e.touches[0].screenX;  const currentY = e.touches[0].screenY;    const diffX = currentX - touchStartX.value;  const diffY = currentY - touchStartY.value;    // Only start dragging if substantially horizontal  if (!isDragging.value) {      if (diffX > 10 && Math.abs(diffX) > Math.abs(diffY)) {          isDragging.value = true;      }  }    if (isDragging.value && diffX > 0) {      // Prevent default scrolling only if we are dragging horizontally      if (e.cancelable) e.preventDefault();       touchOffset.value = diffX;  }};const handleTouchEnd = (e) => {  if (!showMobileChat.value) return;     if (isDragging.value) {      // Enable transition for the snap/exit animation      isDragging.value = false;      // If dragged more than 50% of screen width, close it      const screenWidth = window.innerWidth;      if (touchOffset.value > screenWidth * 0.5) {          // Animate out to the right          touchOffset.value = screenWidth;                     // Wait for transition (300ms) to finish before unmounting/hiding          setTimeout(() => {              backToMenu();              // Reset offset after hidden              setTimeout(() => {                  touchOffset.value = 0;              }, 50);          }, 300);      } else {          // Snap back to 0          touchOffset.value = 0;      }  }};// Mock incoming message for demonstrationconst mockIncomingMessage = () => {    // Mock disabled - using real API data};onMounted(() => {  scrollToBottom();    // Check Local Storage for Session  const storedId = localStorage.getItem('cms_chat_id');  const storedPass = localStorage.getItem('cms_chat_password');    if (storedId && storedPass) {      console.log("Restoring session for ID:", storedId);      authId.value = storedId;      authPassword.value = storedPass;      connectWebSocket();      fetchConversations();  } else {      // Clean up if expired or invalid      localStorage.removeItem('cms_chat_id');      localStorage.removeItem('cms_chat_password');            // Check URL param?      const urlParams = new URLSearchParams(window.location.search);      const idParam = urlParams.get('id');      if (idParam) {          authId.value = idParam;          // Prompt for password          showLoginPrompt.value = true;          // Clean URL          window.history.replaceState({}, document.title, window.location.pathname);      } else {        // Show Login Prompt        setTimeout(() => { showLoginPrompt.value = true; }, 500);      }  }  });  // Handle Android Back Button  App.addListener('backButton', () => {    const timeNow = Date.now();    if (timeNow - lastBackPress < 2000) {        App.exitApp();    } else {        lastBackPress = timeNow;        showExitToast.value = true;        setTimeout(() => {            showExitToast.value = false;        }, 2000);    }  });  // Login Modal Delay Logic  setTimeout(() => {      if (!isConnected.value && !isConnecting.value) {          showLoginPrompt.value = true;      }  }, 1500); // Wait 1.5s before showing modal if not connectedconst logout = () => {    if (socket.value) {        socket.value.close();        socket.value = null;    }    isConnected.value = false;    authId.value = ''; // Reset ID input    isConnecting.value = false; // Ensure loading state is off    showLoginPrompt.value = true; // Show login immediately on logout        // Clear Session    localStorage.removeItem('chat_connection_id');    localStorage.removeItem('chat_connection_expiry');};watch(activeChatId, () => {  scrollToBottom();});</script><template>  <!-- Use fixed inset-0 to prevent body scroll issues on mobile -->  <div class="fixed inset-0 w-full bg-[#0f172a] text-slate-200 overflow-hidden font-sans selection:bg-indigo-500 selection:text-white">        <!-- Login Modal (Overlay) -->    <div v-if="!isConnected && showLoginPrompt" class="fixed inset-0 z-[60] bg-[#0f172a] flex items-center justify-center p-4">       <!-- Login Card -->       <div class="bg-[#1e293b] border border-slate-700 w-full max-w-md rounded-2xl shadow-2xl overflow-hidden">          <!-- Header -->          <div class="p-6 bg-[#1e293b] border-b border-slate-700 text-center">             <div class="w-16 h-16 bg-slate-800 rounded-full mx-auto flex items-center justify-center mb-4 shadow-inner">                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-indigo-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />                </svg>             </div>             <h2 class="text-xl font-bold text-white">Connect to Chat Console</h2>             <p class="text-slate-400 text-sm mt-1">Enter your unique Connection ID to start.</p>          </div>                    <!-- Form -->          <div class="p-8">             <div class="space-y-4">                <div>                   <label class="block text-xs font-semibold text-slate-400 uppercase tracking-wider mb-2">Connection ID</label>                   <input                       v-model="authId"                       type="text"                       placeholder="e.g. 12345"                      @keydown.enter="connect"                      class="w-full bg-[#0f172a] border border-slate-700 rounded-lg px-4 py-3 text-slate-200 focus:outline-none focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 transition-colors"                      :disabled="isConnecting"                   >                </div>